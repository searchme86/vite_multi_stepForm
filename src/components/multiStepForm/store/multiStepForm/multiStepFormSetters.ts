// src/components/multiStepForm/store/multiStepForm/multiStepFormSetters.ts

import type { MultiStepFormState } from './initialMultiStepFormState';
import type { FormValues } from '../../types/formTypes';
import type { StepNumber } from '../../utils/dynamicStepTypes';
import {
  getDefaultFormSchemaValues,
  getAllFieldNames,
  getStringFields,
  getEmailFields,
} from '../../utils/formFieldsLoader';
import { getMinStep, getMaxStep } from '../../utils/dynamicStepTypes';

export interface MultiStepFormSetters {
  readonly setFormValues: (values: FormValues) => void;
  readonly setCurrentStep: (step: StepNumber) => void;
  readonly setProgressWidth: (width: number) => void;
  readonly setShowPreview: (show: boolean) => void;
  readonly setEditorCompletedContent: (content: string) => void;
  readonly setIsEditorCompleted: (completed: boolean) => void;
  readonly updateFormField: <K extends keyof FormValues>(
    field: K,
    value: FormValues[K]
  ) => void;
  readonly resetFormToInitialState: () => void;
}

interface SetterCacheEntry {
  readonly operationHash: string;
  readonly operationType: string;
  readonly timestamp: number;
  readonly executionTime: number;
  readonly affectedFields: readonly string[];
}

interface SetterMetadata {
  readonly totalOperations: number;
  readonly lastOperationTime: number;
  readonly operationHistory: readonly SetterCacheEntry[];
  readonly averageExecutionTime: number;
}

// üîß ÏïàÏ†ÑÌïú Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Í∞ÄÏ†∏Ïò§Í∏∞
const getMemoryUsageSafely = (): number => {
  try {
    const hasPerformance = typeof performance !== 'undefined';
    if (!hasPerformance) {
      return 0;
    }

    const performanceWithMemory = performance;
    const memoryInfo = Reflect.get(performanceWithMemory, 'memory');

    const hasMemoryInfo =
      memoryInfo &&
      typeof Reflect.get(memoryInfo, 'usedJSHeapSize') === 'number';
    if (hasMemoryInfo) {
      const memoryUsage = Reflect.get(memoryInfo, 'usedJSHeapSize');
      return memoryUsage !== null && memoryUsage !== undefined
        ? memoryUsage
        : 0;
    }

    return 0;
  } catch (memoryError) {
    console.warn('‚ö†Ô∏è [SETTERS] Î©îÎ™®Î¶¨ Ï†ïÎ≥¥ Ï†ëÍ∑º Ïã§Ìå®:', memoryError);
    return 0;
  }
};

const setterOperationCache = new Map<string, SetterCacheEntry>();
const setterMetadataWeakMap = new WeakMap<MultiStepFormState, SetterMetadata>();

let isPersistRehydrating = false;
let isInitialLoadComplete = false;

const setPersistRehydrationState = (rehydrating: boolean): void => {
  isPersistRehydrating = rehydrating;

  const shouldInitialize = !rehydrating && !isInitialLoadComplete;
  if (shouldInitialize) {
    console.log('‚úÖ [SETTERS] Persist Î≥µÏõê ÏôÑÎ£å, Ï∫êÏãú Ï¥àÍ∏∞Ìôî');
    setterOperationCache.clear();
    isInitialLoadComplete = true;
  }
};

// üÜï ÎèôÏ†Å FormSettersCacheManager ÌÅ¥ÎûòÏä§
class DynamicFormSettersCacheManager {
  private readonly maxCacheSize: number;
  private readonly cacheExpirationMs: number;
  private cleanupIntervalId: number | undefined;
  private totalSetterOperations: number;
  private operationHistory: SetterCacheEntry[];

  constructor(maxSize: number = 50, expirationMs: number = 5 * 60 * 1000) {
    this.maxCacheSize = maxSize;
    this.cacheExpirationMs = expirationMs;
    this.cleanupIntervalId = undefined;
    this.totalSetterOperations = 0;
    this.operationHistory = [];
    this.startPeriodicCleanup();

    console.log('üß† [SETTERS] ÎèôÏ†Å FormSettersCacheManager Ï¥àÍ∏∞Ìôî:', {
      maxSize,
      expirationMs,
    });
  }

  private startPeriodicCleanup(): void {
    const cleanupIntervalMs = 2 * 60 * 1000;

    this.cleanupIntervalId = window.setInterval(() => {
      if (isPersistRehydrating) {
        console.log('‚è≥ [SETTERS] Persist Î≥µÏõê Ï§ëÏúºÎ°ú Ï∫êÏãú Ï†ïÎ¶¨ ÏßÄÏó∞');
        return;
      }

      this.performCacheCleanup();
    }, cleanupIntervalMs);
  }

  private performCacheCleanup(): void {
    try {
      const currentTime = Date.now();
      const expiredKeys: string[] = [];

      for (const [cacheKey, cacheEntry] of setterOperationCache) {
        const { timestamp } = cacheEntry;
        const cacheAge = currentTime - timestamp;

        const isExpired = cacheAge > this.cacheExpirationMs;
        if (isExpired) {
          expiredKeys.push(cacheKey);
        }
      }

      for (const expiredKey of expiredKeys) {
        setterOperationCache.delete(expiredKey);
      }

      const isOverCapacity = setterOperationCache.size > this.maxCacheSize;
      if (isOverCapacity) {
        const sortedEntries = Array.from(setterOperationCache.entries()).sort(
          ([, entryA], [, entryB]) => entryA.timestamp - entryB.timestamp
        );

        const excessCount = setterOperationCache.size - this.maxCacheSize;
        const entriesToRemove = sortedEntries.slice(0, excessCount);

        for (const [keyToRemove] of entriesToRemove) {
          setterOperationCache.delete(keyToRemove);
        }
      }

      const maxHistorySize = 100;
      const isHistoryOverflow = this.operationHistory.length > maxHistorySize;
      if (isHistoryOverflow) {
        const excessHistoryCount =
          this.operationHistory.length - maxHistorySize;
        this.operationHistory.splice(0, excessHistoryCount);
      }

      console.log(
        'üßπ [SETTERS] ÎèôÏ†Å Ìèº setter Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å, ÌòÑÏû¨ ÌÅ¨Í∏∞:',
        setterOperationCache.size
      );
    } catch (cleanupError) {
      console.error('‚ùå [SETTERS] Ï∫êÏãú Ï†ïÎ¶¨ Ïò§Î•ò:', cleanupError);
    }
  }

  recordOperation(
    operationHash: string,
    operationType: string,
    executionTime: number,
    affectedFields: string[]
  ): void {
    if (isPersistRehydrating) {
      return;
    }

    this.totalSetterOperations += 1;

    const operationEntry: SetterCacheEntry = {
      operationHash,
      operationType,
      timestamp: Date.now(),
      executionTime,
      affectedFields: Object.freeze(affectedFields),
    };

    setterOperationCache.set(operationHash, operationEntry);
    this.operationHistory.push(operationEntry);

    console.log(
      'üìù [SETTERS] setter ÏûëÏóÖ Í∏∞Î°ù:',
      operationType,
      executionTime.toFixed(2),
      'ms'
    );
  }

  getOperationStats(): {
    readonly totalOperations: number;
    readonly cacheSize: number;
    readonly averageExecutionTime: number;
    readonly recentOperationsCount: number;
  } {
    const recentOperations = this.operationHistory.slice(-20);
    const averageExecutionTime =
      recentOperations.length > 0
        ? recentOperations.reduce(
            (sum: number, op: SetterCacheEntry) => sum + op.executionTime,
            0
          ) / recentOperations.length
        : 0;

    return {
      totalOperations: this.totalSetterOperations,
      cacheSize: setterOperationCache.size,
      averageExecutionTime,
      recentOperationsCount: recentOperations.length,
    };
  }

  clearCacheForPersistRestore(): void {
    console.log('üîÑ [SETTERS] Persist Î≥µÏõêÏùÑ ÏúÑÌïú Ï∫êÏãú Ï¥àÍ∏∞Ìôî');
    setterOperationCache.clear();
    this.operationHistory = [];
  }

  destroy(): void {
    const hasCleanupInterval = this.cleanupIntervalId !== undefined;
    if (hasCleanupInterval) {
      window.clearInterval(this.cleanupIntervalId);
      this.cleanupIntervalId = undefined;
    }

    setterOperationCache.clear();
    this.operationHistory = [];
    this.totalSetterOperations = 0;
    console.log('üßπ [SETTERS] ÎèôÏ†Å FormSettersCacheManager ÏôÑÏ†Ñ Ï†ïÎ¶¨');
  }
}

const globalSettersCacheManager = new DynamicFormSettersCacheManager(
  40,
  3 * 60 * 1000
);

const generateOperationHash = (
  operationType: string,
  affectedFields: string[],
  timestamp: number
): string => {
  try {
    const operationData = [
      operationType,
      affectedFields.sort().join('|'),
      String(timestamp),
    ];

    const combinedString = operationData.join('#');

    let hashValue = 0;
    for (let charIndex = 0; charIndex < combinedString.length; charIndex += 1) {
      const charCode = combinedString.charCodeAt(charIndex);
      hashValue = (hashValue << 5) - hashValue + charCode;
      hashValue = hashValue & hashValue;
    }

    return hashValue.toString(36);
  } catch (hashError) {
    console.error('‚ùå [SETTERS] ÏûëÏóÖ Ìï¥Ïãú ÏÉùÏÑ± Ïò§Î•ò:', hashError);
    return `error_${Date.now()}`;
  }
};

const updateSetterMetadata = (
  currentState: MultiStepFormState,
  operationEntry: SetterCacheEntry
): void => {
  try {
    if (isPersistRehydrating) {
      return;
    }

    const existingMetadata = setterMetadataWeakMap.get(currentState);

    const updatedMetadata: SetterMetadata = {
      totalOperations: existingMetadata
        ? existingMetadata.totalOperations + 1
        : 1,
      lastOperationTime: operationEntry.timestamp,
      operationHistory: existingMetadata
        ? [...existingMetadata.operationHistory, operationEntry].slice(-50)
        : [operationEntry],
      averageExecutionTime: existingMetadata
        ? (existingMetadata.averageExecutionTime +
            operationEntry.executionTime) /
          2
        : operationEntry.executionTime,
    };

    setterMetadataWeakMap.set(currentState, updatedMetadata);
  } catch (metadataError) {
    console.error('‚ùå [SETTERS] Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', metadataError);
  }
};

// üÜï ÎèôÏ†Å ÌÉÄÏûÖ Í∞ÄÎìú Ìï®ÏàòÎì§
const createDynamicTypeGuards = () => {
  console.log('üîß [SETTERS] ÎèôÏ†Å ÌÉÄÏûÖ Í∞ÄÎìú ÏÉùÏÑ±');

  const allFieldNames = getAllFieldNames();
  const stringFields = getStringFields();
  const emailFields = getEmailFields();

  const allFieldNamesSet = new Set(allFieldNames);
  const stringFieldsSet = new Set(stringFields);
  const emailFieldsSet = new Set(emailFields);

  const isValidFormValues = (values: unknown): values is FormValues => {
    console.log('üîç [SETTERS] FormValues Í≤ÄÏ¶ù ÏãúÏûë');

    const isObjectType = values !== null && typeof values === 'object';
    if (!isObjectType) {
      console.log('‚ùå [SETTERS] FormValuesÍ∞Ä Í∞ùÏ≤¥Í∞Ä ÏïÑÎãò');
      return false;
    }

    const formValuesCandidate = values;

    // ÎèôÏ†Å ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    const coreRequiredFields = ['nickname', 'title'];
    const emailRequiredFields = Array.from(emailFieldsSet);
    const allRequiredFields = [...coreRequiredFields, ...emailRequiredFields];

    for (const fieldName of allRequiredFields) {
      const hasField = Reflect.has(formValuesCandidate, fieldName);
      if (!hasField) {
        console.log(`‚ùå [SETTERS] ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ: ${fieldName}`);
        return false;
      }
    }

    console.log('‚úÖ [SETTERS] FormValues Í≤ÄÏ¶ù ÏôÑÎ£å');
    return true;
  };

  const isValidStepNumberSafe = (step: unknown): step is StepNumber => {
    console.log('üîç [SETTERS] StepNumber Í≤ÄÏ¶ù:', step);

    const isNumberType = typeof step === 'number';
    if (!isNumberType) {
      console.log('‚ùå [SETTERS] StepNumberÍ∞Ä Ïà´ÏûêÍ∞Ä ÏïÑÎãò');
      return false;
    }

    const minStep = getMinStep();
    const maxStep = getMaxStep();
    const isInRange = step >= minStep && step <= maxStep;
    const isIntegerValue = Number.isInteger(step);

    const isValid = isInRange && isIntegerValue;
    console.log(
      `${isValid ? '‚úÖ' : '‚ùå'} [SETTERS] StepNumber Í≤ÄÏ¶ù Í≤∞Í≥º: ${isValid}`
    );
    return isValid;
  };

  const isValidProgress = (width: unknown): width is number => {
    console.log('üîç [SETTERS] Progress Í≤ÄÏ¶ù:', width);

    const isNumberType = typeof width === 'number';
    if (!isNumberType) {
      console.log('‚ùå [SETTERS] ProgressÍ∞Ä Ïà´ÏûêÍ∞Ä ÏïÑÎãò');
      return false;
    }

    const isInRange = width >= 0 && width <= 100;
    const isFiniteValue = Number.isFinite(width);

    const isValid = isInRange && isFiniteValue;
    console.log(
      `${isValid ? '‚úÖ' : '‚ùå'} [SETTERS] Progress Í≤ÄÏ¶ù Í≤∞Í≥º: ${isValid}`
    );
    return isValid;
  };

  console.log('‚úÖ [SETTERS] ÎèôÏ†Å ÌÉÄÏûÖ Í∞ÄÎìú ÏÉùÏÑ± ÏôÑÎ£å');

  return {
    isValidFormValues,
    isValidStepNumberSafe,
    isValidProgress,
    allFieldNamesSet,
    stringFieldsSet,
    emailFieldsSet,
  };
};

// üÜï ÎèôÏ†Å FormValues ÏÉùÏÑ± Ìï®Ïàò
const createDynamicDefaultFormValues = (): FormValues => {
  console.log('üîß [SETTERS] ÎèôÏ†Å Í∏∞Î≥∏ FormValues ÏÉùÏÑ± ÏãúÏûë');

  try {
    const dynamicFormValues = getDefaultFormSchemaValues();

    console.log('‚úÖ [SETTERS] ÎèôÏ†Å Í∏∞Î≥∏ FormValues ÏÉùÏÑ± ÏôÑÎ£å:', {
      fieldCount: Object.keys(dynamicFormValues).length,
      fieldNames: Object.keys(dynamicFormValues),
      timestamp: new Date().toISOString(),
    });

    return dynamicFormValues;
  } catch (formValuesError) {
    console.error('‚ùå [SETTERS] ÎèôÏ†Å FormValues ÏÉùÏÑ± Ïã§Ìå®:', formValuesError);

    // Fallback
    return {
      userImage: '',
      nickname: '',
      emailPrefix: '',
      emailDomain: '',
      bio: '',
      title: '',
      description: '',
      media: [],
      mainImage: null,
      sliderImages: [],
      editorCompletedContent: '',
      isEditorCompleted: false,
    };
  }
};

// üÜï ÎèôÏ†Å MultiStepFormSetters ÏÉùÏÑ±
export const createMultiStepFormSetters = (
  set: (updater: (state: MultiStepFormState) => MultiStepFormState) => void
): MultiStepFormSetters => {
  console.log('üîß [SETTERS] ÎèôÏ†Å MultiStepFormSetters ÏÉùÏÑ± Ï§ë...');

  const typeGuards = createDynamicTypeGuards();
  const { isValidFormValues, isValidStepNumberSafe, isValidProgress } =
    typeGuards;

  return {
    setFormValues: (values: FormValues): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] setFormValues Ïã§Ìñâ ÏãúÏûë');

      const isValidValues = isValidFormValues(values);
      if (!isValidValues) {
        console.warn('‚ö†Ô∏è [SETTERS] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ FormValues:', values);
        return;
      }

      set((currentState) => {
        try {
          const updatedState: MultiStepFormState = {
            ...currentState,
            formValues: { ...values },
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'setFormValues',
            ['formValues'],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'setFormValues',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze(['formValues']),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'setFormValues',
            executionTime,
            ['formValues']
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] setFormValues ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (setterError) {
          console.error('‚ùå [SETTERS] setFormValues Ïò§Î•ò:', setterError);
          return currentState;
        }
      });
    },

    setCurrentStep: (step: StepNumber): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] setCurrentStep Ïã§Ìñâ ÏãúÏûë:', step);

      const isValidStep = isValidStepNumberSafe(step);
      if (!isValidStep) {
        console.warn('‚ö†Ô∏è [SETTERS] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïä§ÌÖù:', step);
        return;
      }

      set((currentState) => {
        try {
          const updatedState: MultiStepFormState = {
            ...currentState,
            currentStep: step,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'setCurrentStep',
            ['currentStep'],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'setCurrentStep',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze(['currentStep']),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'setCurrentStep',
            executionTime,
            ['currentStep']
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] setCurrentStep ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (setterError) {
          console.error('‚ùå [SETTERS] setCurrentStep Ïò§Î•ò:', setterError);
          return currentState;
        }
      });
    },

    setProgressWidth: (width: number): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] setProgressWidth Ïã§Ìñâ ÏãúÏûë:', width);

      const isValidWidth = isValidProgress(width);
      if (!isValidWidth) {
        console.warn('‚ö†Ô∏è [SETTERS] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏßÑÌñâÎ•†:', width);
        return;
      }

      set((currentState) => {
        try {
          const updatedState: MultiStepFormState = {
            ...currentState,
            progressWidth: width,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'setProgressWidth',
            ['progressWidth'],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'setProgressWidth',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze(['progressWidth']),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'setProgressWidth',
            executionTime,
            ['progressWidth']
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] setProgressWidth ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (setterError) {
          console.error('‚ùå [SETTERS] setProgressWidth Ïò§Î•ò:', setterError);
          return currentState;
        }
      });
    },

    setShowPreview: (show: boolean): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] setShowPreview Ïã§Ìñâ ÏãúÏûë:', show);

      const isBooleanType = typeof show === 'boolean';
      if (!isBooleanType) {
        console.warn('‚ö†Ô∏è [SETTERS] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÉÅÌÉú:', show);
        return;
      }

      set((currentState) => {
        try {
          const updatedState: MultiStepFormState = {
            ...currentState,
            showPreview: show,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'setShowPreview',
            ['showPreview'],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'setShowPreview',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze(['showPreview']),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'setShowPreview',
            executionTime,
            ['showPreview']
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] setShowPreview ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (setterError) {
          console.error('‚ùå [SETTERS] setShowPreview Ïò§Î•ò:', setterError);
          return currentState;
        }
      });
    },

    setEditorCompletedContent: (content: string): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] setEditorCompletedContent Ïã§Ìñâ ÏãúÏûë');

      const isStringType = typeof content === 'string';
      if (!isStringType) {
        console.warn('‚ö†Ô∏è [SETTERS] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏóêÎîîÌÑ∞ ÎÇ¥Ïö©:', typeof content);
        return;
      }

      set((currentState) => {
        try {
          const updatedState: MultiStepFormState = {
            ...currentState,
            editorCompletedContent: content,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'setEditorCompletedContent',
            ['editorCompletedContent'],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'setEditorCompletedContent',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze(['editorCompletedContent']),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'setEditorCompletedContent',
            executionTime,
            ['editorCompletedContent']
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] setEditorCompletedContent ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (setterError) {
          console.error(
            '‚ùå [SETTERS] setEditorCompletedContent Ïò§Î•ò:',
            setterError
          );
          return currentState;
        }
      });
    },

    setIsEditorCompleted: (completed: boolean): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] setIsEditorCompleted Ïã§Ìñâ ÏãúÏûë:', completed);

      const isBooleanType = typeof completed === 'boolean';
      if (!isBooleanType) {
        console.warn('‚ö†Ô∏è [SETTERS] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏóêÎîîÌÑ∞ ÏôÑÎ£å ÏÉÅÌÉú:', completed);
        return;
      }

      set((currentState) => {
        try {
          const updatedState: MultiStepFormState = {
            ...currentState,
            isEditorCompleted: completed,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'setIsEditorCompleted',
            ['isEditorCompleted'],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'setIsEditorCompleted',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze(['isEditorCompleted']),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'setIsEditorCompleted',
            executionTime,
            ['isEditorCompleted']
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] setIsEditorCompleted ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (setterError) {
          console.error('‚ùå [SETTERS] setIsEditorCompleted Ïò§Î•ò:', setterError);
          return currentState;
        }
      });
    },

    updateFormField: <K extends keyof FormValues>(
      field: K,
      value: FormValues[K]
    ): void => {
      const startTime = performance.now();
      console.log('üîß [SETTERS] updateFormField Ïã§Ìñâ ÏãúÏûë:', { field, value });

      set((currentState) => {
        try {
          const isValidState = currentState && typeof currentState === 'object';
          if (!isValidState) {
            console.error(
              '‚ùå [SETTERS] updateFormField: Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌòÑÏû¨ ÏÉÅÌÉú'
            );
            return currentState;
          }

          const { formValues = createDynamicDefaultFormValues() } =
            currentState;

          const updatedFormValues: FormValues = {
            ...formValues,
            [field]: value,
          };

          const updatedState: MultiStepFormState = {
            ...currentState,
            formValues: updatedFormValues,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'updateFormField',
            [String(field)],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'updateFormField',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze([String(field)]),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'updateFormField',
            executionTime,
            [String(field)]
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] updateFormField ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (updateError) {
          console.error('‚ùå [SETTERS] updateFormField Ïò§Î•ò:', updateError);
          return currentState;
        }
      });
    },

    resetFormToInitialState: (): void => {
      const startTime = performance.now();
      console.log('üîÑ [SETTERS] resetFormToInitialState Ïã§Ìñâ ÏãúÏûë');

      set((currentState) => {
        try {
          const initialFormValues = createDynamicDefaultFormValues();
          const minStep = getMinStep();

          const updatedState: MultiStepFormState = {
            ...currentState,
            formValues: initialFormValues,
            currentStep: minStep,
            progressWidth: 0,
            showPreview: false,
            editorCompletedContent: '',
            isEditorCompleted: false,
          };

          const executionTime = performance.now() - startTime;
          const operationHash = generateOperationHash(
            'resetFormToInitialState',
            [
              'formValues',
              'currentStep',
              'progressWidth',
              'showPreview',
              'editorCompletedContent',
              'isEditorCompleted',
            ],
            Date.now()
          );

          const operationEntry: SetterCacheEntry = {
            operationHash,
            operationType: 'resetFormToInitialState',
            timestamp: Date.now(),
            executionTime,
            affectedFields: Object.freeze([
              'formValues',
              'currentStep',
              'progressWidth',
              'showPreview',
              'editorCompletedContent',
              'isEditorCompleted',
            ]),
          };

          globalSettersCacheManager.recordOperation(
            operationHash,
            'resetFormToInitialState',
            executionTime,
            [
              'formValues',
              'currentStep',
              'progressWidth',
              'showPreview',
              'editorCompletedContent',
              'isEditorCompleted',
            ]
          );

          updateSetterMetadata(updatedState, operationEntry);
          console.log(
            '‚úÖ [SETTERS] resetFormToInitialState ÏôÑÎ£å:',
            executionTime.toFixed(2),
            'ms'
          );

          return updatedState;
        } catch (resetError) {
          console.error(
            '‚ùå [SETTERS] resetFormToInitialState Ïò§Î•ò:',
            resetError
          );
          return currentState;
        }
      });
    },
  };
};

// üÜï ÎèôÏ†Å Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
export const clearFormSettersCache = (): void => {
  globalSettersCacheManager.destroy();
  console.log('üßπ [SETTERS] ÎèôÏ†Å Ìèº setter Ï∫êÏãú ÏôÑÏ†Ñ Ï†ïÎ¶¨');
};

export const getFormSettersStats = (): {
  readonly operationStats: ReturnType<
    typeof globalSettersCacheManager.getOperationStats
  >;
  readonly memoryUsageMB: number;
  readonly isPersistRehydrating: boolean;
} => {
  const operationStats = globalSettersCacheManager.getOperationStats();
  const memoryUsageBytes = getMemoryUsageSafely();
  const memoryUsageMB = memoryUsageBytes / (1024 * 1024);

  return {
    operationStats,
    memoryUsageMB,
    isPersistRehydrating,
  };
};

export const getSetterMetadata = (
  state: MultiStepFormState
): SetterMetadata | undefined => {
  try {
    return setterMetadataWeakMap.get(state);
  } catch (metadataError) {
    console.error('‚ùå [SETTERS] Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò:', metadataError);
    return undefined;
  }
};

export const handlePersistRestoreSetters = (): void => {
  console.log('üîÑ [SETTERS] ÎèôÏ†Å Persist Î≥µÏõê Ìï∏Îì§ÎßÅ ÏãúÏûë');
  setPersistRehydrationState(true);
  globalSettersCacheManager.clearCacheForPersistRestore();
};

export const completePersistRestoreSetters = (): void => {
  console.log('‚úÖ [SETTERS] ÎèôÏ†Å Persist Î≥µÏõê ÏôÑÎ£å');
  setPersistRehydrationState(false);
};

export const forceFormSettersCleanup = (): void => {
  globalSettersCacheManager.destroy();

  const hasWindow = typeof window !== 'undefined';
  if (hasWindow) {
    try {
      const windowWithGC = window;
      const hasGCFunction =
        typeof Reflect.get(windowWithGC, 'gc') === 'function';
      if (hasGCFunction) {
        const gcFunction = Reflect.get(windowWithGC, 'gc');
        gcFunction();
        console.log('üßπ [SETTERS] Î∏åÎùºÏö∞Ï†Ä GC Í∞ïÏ†ú Ïã§Ìñâ');
      }
    } catch (gcError) {
      console.log('‚ö†Ô∏è [SETTERS] GC Ïã§Ìñâ Ïã§Ìå®:', gcError);
    }
  }

  console.log('üßπ [SETTERS] ÎèôÏ†Å Ìèº setter Í∞ïÏ†ú Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏôÑÎ£å');
};

console.log(
  'üìÑ [SETTERS] ‚úÖ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî Î≥ÄÏàò Ï†úÍ±∞ ÏôÑÎ£åÎêú multiStepFormSetters Î™®Îìà Î°úÎìú ÏôÑÎ£å'
);
console.log('üéØ [SETTERS] Ï£ºÏöî ÏàòÏ†ïÏÇ¨Ìï≠:', {
  unusedImportsRemoved: 'ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî import ÏôÑÏ†Ñ Ï†úÍ±∞',
  cleanCodeStructure: 'ÍπîÎÅîÌïú ÏΩîÎìú Íµ¨Ï°∞ Ïú†ÏßÄ',
  typeValidators: 'ÏûêÏ≤¥ ÌÉÄÏûÖ Í≤ÄÏ¶ùÍ∏∞ Íµ¨ÌòÑ',
  maintainedFunctionality: 'Í∏∞Ï°¥ Í∏∞Îä• ÏôÑÏ†Ñ Ïú†ÏßÄ',
});
